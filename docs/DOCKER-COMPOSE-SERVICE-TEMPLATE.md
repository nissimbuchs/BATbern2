# Adding a New Service to Docker Compose

This guide explains how to add a new microservice to the BATbern platform's docker-compose setup.

## Prerequisites

- Service source code in `services/{service-name}/` or similar directory
- Service uses Spring Boot with Gradle (for Java services) or has a similar build system
- Service needs to connect to AWS RDS PostgreSQL, local Redis, or AWS services (Cognito, S3, EventBridge)
- AWS credentials configured with access to DEV environment

## Step 1: Create Dockerfile.dev

Create `services/{service-name}/Dockerfile.dev`:

```dockerfile
FROM gradle:8.5-jdk21 AS development

# Set working directory
WORKDIR /app

# Copy gradle configuration first for better caching
COPY build.gradle settings.gradle ./
COPY gradle ./gradle

# Download dependencies (cached layer)
RUN gradle dependencies --no-daemon || true

# Copy source code
COPY src ./src

# Expose application port
EXPOSE 8081

# Enable Gradle continuous build for hot reload
ENTRYPOINT ["gradle", "bootRun", "--continuous", "--no-daemon", "--info"]
```

**Note:** Change port number (8081) to the next available port for your service.

## Step 2: Add Service to docker-compose.yml

Add the service configuration to `docker-compose.yml`:

```yaml
  {service-name}:
    build:
      context: ./services/{service-name}
      dockerfile: Dockerfile.dev
    container_name: batbern-{service-name}
    ports:
      - "{port}:{port}"  # e.g., "8081:8081"
    environment:
      # Spring Configuration
      - SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE:-local}
      - LOG_LEVEL=${LOG_LEVEL:-DEBUG}

      # AWS Configuration
      - AWS_REGION=${AWS_REGION:-eu-central-1}

      # Database Configuration (AWS RDS)
      - DB_HOST=${DB_HOST}
      - DB_PORT=${DB_PORT:-5432}
      - DB_NAME=${DB_NAME}
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - DATABASE_URL=${DATABASE_URL}

      # Redis Configuration (Local Container)
      - REDIS_HOST=${REDIS_HOST:-redis}
      - REDIS_PORT=${REDIS_PORT:-6379}

      # Cognito Configuration (AWS)
      - COGNITO_USER_POOL_ID=${COGNITO_USER_POOL_ID}
      - COGNITO_CLIENT_ID=${COGNITO_CLIENT_ID}

      # Feature Flags
      - ENABLE_COGNITO_AUTH=${ENABLE_COGNITO_AUTH:-true}
    volumes:
      - ./services/{service-name}:/app
      - gradle-cache:/root/.gradle
    depends_on:
      redis:
        condition: service_healthy
      api-gateway:
        condition: service_healthy  # If service depends on API Gateway
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{port}/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - batbern-network
```

## Step 3: No .env Changes Needed

The `.env` file is auto-generated by `scripts/dev/setup-env.sh` from AWS CDK stack outputs. Database credentials, Cognito configuration, and other AWS resources are automatically fetched.

If your service needs custom environment variables:
1. Add them to `scripts/dev/setup-env.sh` to fetch from AWS
2. Or add them manually to `.env` after running the setup script

## Step 4: Configure Service Application Properties

Update `services/{service-name}/src/main/resources/application.yml`:

```yaml
server:
  port: ${SERVER_PORT:8081}

spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:local}
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:batbern_dev}
    username: ${DB_USER:batbern}
    password: ${DB_PASSWORD:dev_password}
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
  cloud:
    aws:
      endpoint: ${AWS_ENDPOINT:}
      region:
        static: ${AWS_REGION:eu-central-1}
      credentials:
        access-key: ${AWS_ACCESS_KEY_ID:}
        secret-key: ${AWS_SECRET_ACCESS_KEY:}

logging:
  level:
    root: ${LOG_LEVEL:INFO}
    ch.batbern: DEBUG
```

## Step 5: Test the Service

```bash
# Build and start the new service
docker-compose up -d {service-name}

# View logs
docker-compose logs -f {service-name}

# Check health
curl http://localhost:{port}/actuator/health

# Verify database connection
docker-compose exec {service-name} \
  curl http://localhost:{port}/actuator/health | jq '.components.db'
```

## Step 6: Update Documentation

1. Update `README.md` to mention the new service
2. Update this document if you discover better practices
3. Update `.env.example` with any service-specific variables

## Port Assignments

Keep track of port assignments to avoid conflicts:

| Service | Port | Status |
|---------|------|--------|
| API Gateway | 8080 | âœ… Assigned |
| Company Management | 8081 | ðŸ“‹ Planned |
| Event Management | 8082 | ðŸ“‹ Planned |
| Speaker Coordination | 8083 | ðŸ“‹ Planned |
| Partner Analytics | 8084 | ðŸ“‹ Planned |
| Attendee Experience | 8085 | ðŸ“‹ Planned |

## Frontend Service Template (React/Vite)

For frontend services, use this template:

```yaml
  web-frontend:
    build:
      context: ./web-frontend
      dockerfile: Dockerfile.dev
    container_name: batbern-frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_BASE_URL=http://api-gateway:8080
      - VITE_AWS_REGION=${AWS_REGION:-eu-central-1}
    volumes:
      - ./web-frontend:/app
      - /app/node_modules
    depends_on:
      api-gateway:
        condition: service_healthy
    networks:
      - batbern-network
```

**Frontend Dockerfile.dev:**

```dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
```

## Troubleshooting

### Service won't start
- Check logs: `docker-compose logs {service-name}`
- Verify port is not in use: `lsof -i :{port}`
- Ensure dependencies are healthy: `docker-compose ps`

### Can't connect to AWS RDS database
- Verify DB_HOST is set correctly in .env (should be AWS RDS endpoint)
- Check .env was generated: `cat .env | grep DB_HOST`
- Regenerate .env: `AWS_PROFILE=batbern-mgmt ./scripts/dev/setup-env.sh`
- Check application logs: `docker-compose logs {service-name}`

### Hot reload not working
- Ensure volumes are correctly mounted
- Restart service: `docker-compose restart {service-name}`
- Try rebuilding: `docker-compose up -d --build {service-name}`

## Best Practices

1. **Always use health checks** - Ensures dependent services wait for readiness
2. **Use environment variables** - Never hardcode configuration
3. **Mount source as volume** - Enables hot reload during development
4. **Cache dependencies** - Use multi-stage builds to cache Gradle/npm dependencies
5. **Use service names for networking** - Docker DNS resolves service names automatically
6. **Set start_period in healthchecks** - Gives services time to start before failing health checks

## Example: Complete Service Addition

See `api-gateway` service in `docker-compose.yml` as a reference implementation.
