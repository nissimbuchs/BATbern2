# Story 1.3: Multi-Environment CDK Infrastructure Setup

## Status
Draft

## Story
**As a** DevOps engineer,
**I want** to define and provision complete infrastructure for dev, staging, and production environments using AWS CDK,
**so that** we have consistent, reproducible environments across the development lifecycle.

## Domain Context

### Primary Domain
Shared Infrastructure & Core Services - Cross-cutting infrastructure foundation for all domains

### Involved Services
- All Domain Services (as deployment targets)
- API Gateway (infrastructure deployment)
- AWS CDK Infrastructure (new)
- AWS Resources (RDS, ElastiCache, S3, VPC, ECS/Fargate)

### Cross-Domain Dependencies
- **Depends on**: Story 1.1 (Shared Kernel) and Story 1.2 (API Gateway & Authentication) for service configurations
- **Enables**: All subsequent domain service deployments
- **Integration**: Provides infrastructure for Event Management, Speaker Coordination, Partner Analytics, and Attendee Experience services

## Requirements Context

### Related Functional Requirements
- **NFR3**: Integration with external services (email, payment processing, file storage) through configurable APIs
- **CR1**: Migrate all existing event data (54+ events, presentations, speaker profiles) without data loss
- **CR3**: Preserve existing URL structure for SEO and bookmark compatibility where feasible

### Workflow Steps (if applicable)
N/A - Infrastructure story supporting all workflow steps

### Acceptance Criteria Source
Epic 1, Story 1.3, Lines 145-192

## Architecture Context

### Architecture Patterns
[Source: architecture/02-infrastructure-deployment.md]
- **Deployment Strategy**: AWS ECS Fargate with Blue/Green deployment
- **DNS Management**: AWS Route53 with automatic certificate validation
- **Monitoring Stack**: CloudWatch, Grafana, X-Ray for comprehensive observability
- **Environment Isolation**: Separate VPCs per environment with proper subnet configuration

[Source: architecture/tech-stack.md]
- **IaC Tool**: AWS CDK 2.110+ with TypeScript for type-safe infrastructure
- **Container Orchestration**: AWS ECS Fargate for serverless scaling
- **Database**: PostgreSQL 15+ on AWS RDS with Multi-AZ deployment
- **Caching**: Redis 7.2+ on ElastiCache with clustering

### Infrastructure Components
[Source: architecture/02-infrastructure-deployment.md#L69-L117]
- **AWS Certificate Manager**: SSL certificates for *.batbern.ch domains
- **Route53 Hosted Zone**: DNS management for batbern.ch
- **CloudFront Distributions**: CDN for frontend applications per environment
- **API Gateway Domains**: Custom domains for API endpoints
- **VPC Configuration**: Isolated networks with public/private subnets
- **RDS PostgreSQL**: Multi-AZ database instances with automated backups
- **ElastiCache Redis**: Clustered cache instances per environment
- **S3 Buckets**: Static content, logs, and backup storage
- **ECS Clusters**: Container orchestration per environment
- **ALB/NLB**: Load balancers for service distribution

## Wireframe Context

### Wireframe References
N/A - Infrastructure story

### UI Components
N/A - Infrastructure story

## Acceptance Criteria

1. **CDK Stack Architecture**: Separate stacks for each environment with shared base stack
2. **Environment Configuration**: Environment-specific parameters and resource sizing
3. **Network Isolation**: VPC per environment with proper subnet configuration
4. **Security Boundaries**: IAM roles and policies enforcing least privilege
5. **Resource Tagging**: Consistent tagging for cost allocation and management
6. **RDS Configuration**: Multi-AZ PostgreSQL with environment-appropriate sizing
7. **Database Migrations**: Flyway integration for schema versioning
8. **Backup Strategy**: Automated backups with environment-specific retention
9. **Connection Pooling**: PgBouncer or RDS Proxy configuration
10. **ECS/Fargate Setup**: Container orchestration for microservices
11. **Load Balancers**: ALB configuration with health checks
12. **Auto-scaling**: Environment-specific scaling policies
13. **Service Discovery**: AWS Cloud Map for service-to-service communication
14. **Redis Clusters**: ElastiCache Redis with appropriate clustering
15. **S3 Buckets**: Content storage with lifecycle policies
16. **CloudFront**: CDN distribution for static content
17. **Secrets Manager**: Secure credential storage and rotation

## Test Specifications (TDD)

### Test Scenarios by Acceptance Criteria

**AC1 Tests (CDK Stack Architecture):**
- Test 1.1: should_createSeparateStacks_when_deployingEnvironments
- Test 1.2: should_shareBaseStackResources_when_referencedByEnvStacks
- Test 1.3: should_preventCrossDependencies_when_stacksIsolated

**AC2 Tests (Environment Configuration):**
- Test 2.1: should_loadEnvironmentConfig_when_deployingStack
- Test 2.2: should_applyResourceSizing_when_environmentSpecified
- Test 2.3: should_throwError_when_requiredConfigMissing

**AC3-5 Tests (Network & Security):**
- Test 3.1: should_createIsolatedVPC_when_environmentDeployed
- Test 4.1: should_enforceLeasePrivilege_when_creatingIAMRoles
- Test 5.1: should_applyConsistentTags_when_creatingResources

**AC6-9 Tests (Database Infrastructure):**
- Test 6.1: should_configureMultiAZ_when_productionEnvironment
- Test 7.1: should_integrateFlywayMigrations_when_databaseCreated
- Test 8.1: should_configureBackupRetention_when_RDSProvisioned
- Test 9.1: should_setupConnectionPooling_when_databaseReady

**AC10-13 Tests (Container Infrastructure):**
- Test 10.1: should_createECSCluster_when_environmentDeployed
- Test 11.1: should_configureHealthChecks_when_ALBCreated
- Test 12.1: should_applyAutoScaling_when_serviceDeployed
- Test 13.1: should_enableServiceDiscovery_when_servicesRegistered

**AC14-17 Tests (Supporting Services):**
- Test 14.1: should_createRedisCluster_when_cacheRequired
- Test 15.1: should_applyLifecyclePolicies_when_S3BucketCreated
- Test 16.1: should_configureCDN_when_frontendDeployed
- Test 17.1: should_rotateSecrets_when_credentialsStored

### Test File Locations

**CDK Infrastructure Tests:**
- Unit Tests: `infrastructure/test/unit/stacks/*.test.ts`
- Integration Tests: `infrastructure/test/integration/*.test.ts`
- Snapshot Tests: `infrastructure/test/snapshots/*.test.ts`

**Deployment Tests:**
- Environment Tests: `infrastructure/test/environments/*.test.ts`
- Resource Tests: `infrastructure/test/resources/*.test.ts`

### Test Data & Mocks

**Test Configurations:**
- Mock environment configurations for dev/staging/prod
- Test VPC configurations with CIDR ranges
- Mock secret values for testing

**CDK Test Utilities:**
- AWS CDK Testing Framework (@aws-cdk/assertions)
- Template.fromStack() for stack validation
- Capture utilities for resource property validation

## Tasks / Subtasks (TDD Workflow)

- [ ] Task 1: Setup CDK Project Structure (RED Phase)
  - [ ] Initialize CDK TypeScript project with proper structure
  - [ ] Write failing tests for stack creation
  - [ ] Configure TypeScript and CDK dependencies
  - [ ] Setup test framework for infrastructure code

- [ ] Task 2: Core Infrastructure Stack (AC: 1-5)
  - [ ] Write failing tests for VPC creation
  - [ ] Write failing tests for security group configuration
  - [ ] Write failing tests for IAM roles and policies
  - [ ] Implement VPC with public/private subnets (GREEN)
  - [ ] Implement security groups and NACLs (GREEN)
  - [ ] Implement IAM roles with least privilege (GREEN)
  - [ ] Refactor and optimize stack organization (REFACTOR)

- [ ] Task 3: Database Infrastructure (AC: 6-9)
  - [ ] Write failing tests for RDS instance creation
  - [ ] Write failing tests for database security
  - [ ] Write failing tests for backup configuration
  - [ ] Implement RDS PostgreSQL with Multi-AZ (GREEN)
  - [ ] Implement Flyway migration support (GREEN)
  - [ ] Configure automated backups and snapshots (GREEN)
  - [ ] Setup RDS Proxy for connection pooling (GREEN)

- [ ] Task 4: Container Infrastructure (AC: 10-13)
  - [ ] Write failing tests for ECS cluster creation
  - [ ] Write failing tests for Fargate service configuration
  - [ ] Write failing tests for ALB and target groups
  - [ ] Implement ECS cluster and task definitions (GREEN)
  - [ ] Configure ALB with health checks (GREEN)
  - [ ] Setup auto-scaling policies (GREEN)
  - [ ] Enable Cloud Map service discovery (GREEN)

- [ ] Task 5: Caching & Storage (AC: 14-16)
  - [ ] Write failing tests for ElastiCache cluster
  - [ ] Write failing tests for S3 bucket policies
  - [ ] Write failing tests for CloudFront distribution
  - [ ] Implement Redis cluster configuration (GREEN)
  - [ ] Setup S3 buckets with lifecycle policies (GREEN)
  - [ ] Configure CloudFront CDN (GREEN)

- [ ] Task 6: Secrets & Configuration (AC: 17)
  - [ ] Write failing tests for Secrets Manager
  - [ ] Write failing tests for Parameter Store
  - [ ] Implement secret storage and rotation (GREEN)
  - [ ] Configure environment-specific parameters (GREEN)

- [ ] Task 7: Environment-Specific Stacks
  - [ ] Create development environment stack
  - [ ] Create staging environment stack
  - [ ] Create production environment stack
  - [ ] Validate cross-stack references

- [ ] Task 8: Monitoring & Observability
  - [ ] Setup CloudWatch dashboards
  - [ ] Configure log groups and retention
  - [ ] Implement CloudWatch alarms
  - [ ] Setup X-Ray tracing

## Dev Notes - Implementation Guide

### Technical Design Notes

**Stack Organization Structure:**
```typescript
infrastructure/
├── lib/
│   ├── stacks/
│   │   ├── base-stack.ts          // Shared resources
│   │   ├── network-stack.ts       // VPC and networking
│   │   ├── database-stack.ts      // RDS and ElastiCache
│   │   ├── compute-stack.ts       // ECS and Fargate
│   │   ├── storage-stack.ts       // S3 and CloudFront
│   │   └── monitoring-stack.ts    // CloudWatch and X-Ray
│   ├── constructs/
│   │   ├── vpc-construct.ts       // Reusable VPC construct
│   │   ├── ecs-service.ts         // ECS service pattern
│   │   └── rds-cluster.ts         // RDS configuration
│   └── config/
│       ├── dev-config.ts          // Development settings
│       ├── staging-config.ts      // Staging settings
│       └── prod-config.ts         // Production settings
```

**Environment Configuration Pattern:**
```typescript
// config/environment-config.ts
export interface EnvironmentConfig {
  envName: string;
  region: string;
  account: string;
  vpc: {
    cidr: string;
    maxAzs: number;
    natGateways: number;
  };
  rds: {
    instanceClass: ec2.InstanceClass;
    instanceSize: ec2.InstanceSize;
    multiAz: boolean;
    backupRetention: cdk.Duration;
  };
  elasticache: {
    nodeType: string;
    numNodes: number;
    automaticFailoverEnabled: boolean;
  };
  ecs: {
    desiredCount: number;
    cpu: number;
    memory: number;
    autoScaling: {
      minCapacity: number;
      maxCapacity: number;
      targetCpuUtilization: number;
    };
  };
}
```

### API Contracts

N/A - Infrastructure story

### CDK Implementation Patterns

**VPC Configuration:**
```typescript
// lib/stacks/network-stack.ts
import * as ec2 from 'aws-cdk-lib/aws-ec2';

export class NetworkStack extends cdk.Stack {
  public readonly vpc: ec2.Vpc;

  constructor(scope: Construct, id: string, props: NetworkStackProps) {
    super(scope, id, props);

    this.vpc = new ec2.Vpc(this, 'BATbernVPC', {
      maxAzs: props.config.vpc.maxAzs,
      cidr: props.config.vpc.cidr,
      natGateways: props.config.vpc.natGateways,
      subnetConfiguration: [
        {
          name: 'Public',
          subnetType: ec2.SubnetType.PUBLIC,
          cidrMask: 24
        },
        {
          name: 'Private',
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
          cidrMask: 24
        },
        {
          name: 'Isolated',
          subnetType: ec2.SubnetType.PRIVATE_ISOLATED,
          cidrMask: 24
        }
      ],
      enableDnsHostnames: true,
      enableDnsSupport: true
    });

    // Tag all resources
    cdk.Tags.of(this.vpc).add('Environment', props.config.envName);
    cdk.Tags.of(this.vpc).add('Project', 'BATbern');
  }
}
```

**RDS PostgreSQL Configuration:**
```typescript
// lib/stacks/database-stack.ts
import * as rds from 'aws-cdk-lib/aws-rds';

const dbCluster = new rds.DatabaseInstance(this, 'PostgreSQL', {
  engine: rds.DatabaseInstanceEngine.postgres({
    version: rds.PostgresEngineVersion.VER_15_4
  }),
  instanceType: ec2.InstanceType.of(
    props.config.rds.instanceClass,
    props.config.rds.instanceSize
  ),
  vpc: props.vpc,
  vpcSubnets: {
    subnetType: ec2.SubnetType.PRIVATE_ISOLATED
  },
  multiAz: props.config.rds.multiAz,
  allocatedStorage: 100,
  storageType: rds.StorageType.GP3,
  storageEncrypted: true,
  backupRetention: props.config.rds.backupRetention,
  preferredBackupWindow: '03:00-04:00',
  preferredMaintenanceWindow: 'sun:04:00-sun:05:00',
  deletionProtection: props.config.envName === 'production',
  removalPolicy: props.config.envName === 'production'
    ? cdk.RemovalPolicy.RETAIN
    : cdk.RemovalPolicy.DESTROY,
  parameterGroup: new rds.ParameterGroup(this, 'PostgresParams', {
    engine: rds.DatabaseInstanceEngine.postgres({
      version: rds.PostgresEngineVersion.VER_15_4
    }),
    parameters: {
      'shared_preload_libraries': 'pg_stat_statements',
      'log_statement': 'all',
      'log_duration': 'on'
    }
  })
});
```

**ElastiCache Redis Configuration:**
```typescript
// lib/stacks/database-stack.ts
import * as elasticache from 'aws-cdk-lib/aws-elasticache';

const cacheSubnetGroup = new elasticache.CfnSubnetGroup(this, 'CacheSubnetGroup', {
  description: 'Subnet group for ElastiCache',
  subnetIds: props.vpc.privateSubnets.map(subnet => subnet.subnetId)
});

const cacheCluster = new elasticache.CfnReplicationGroup(this, 'RedisCluster', {
  replicationGroupDescription: 'BATbern Redis Cache Cluster',
  engine: 'redis',
  engineVersion: '7.2',
  cacheNodeType: props.config.elasticache.nodeType,
  numNodeGroups: props.config.elasticache.numNodes,
  automaticFailoverEnabled: props.config.elasticache.automaticFailoverEnabled,
  multiAzEnabled: true,
  cacheSubnetGroupName: cacheSubnetGroup.ref,
  securityGroupIds: [cacheSecurityGroup.securityGroupId],
  atRestEncryptionEnabled: true,
  transitEncryptionEnabled: true,
  snapshotRetentionLimit: 5,
  snapshotWindow: '03:00-05:00',
  preferredMaintenanceWindow: 'sun:05:00-sun:07:00',
  tags: [
    { key: 'Environment', value: props.config.envName },
    { key: 'Service', value: 'Cache' }
  ]
});
```

**ECS Fargate Service Pattern:**
```typescript
// lib/constructs/ecs-service.ts
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ecsPatterns from 'aws-cdk-lib/aws-ecs-patterns';

export class EcsService extends Construct {
  constructor(scope: Construct, id: string, props: EcsServiceProps) {
    super(scope, id);

    const taskDefinition = new ecs.FargateTaskDefinition(this, 'TaskDef', {
      cpu: props.cpu,
      memoryLimitMiB: props.memory,
      runtimePlatform: {
        operatingSystemFamily: ecs.OperatingSystemFamily.LINUX,
        cpuArchitecture: ecs.CpuArchitecture.ARM64
      }
    });

    const container = taskDefinition.addContainer('Container', {
      image: ecs.ContainerImage.fromEcrRepository(props.repository),
      logging: ecs.LogDrivers.awsLogs({
        streamPrefix: props.serviceName,
        logRetention: logs.RetentionDays.ONE_MONTH
      }),
      environment: props.environment,
      secrets: props.secrets
    });

    container.addPortMappings({
      containerPort: props.containerPort,
      protocol: ecs.Protocol.TCP
    });

    const service = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'Service', {
      cluster: props.cluster,
      taskDefinition,
      publicLoadBalancer: false,
      desiredCount: props.desiredCount,
      domainName: props.domainName,
      domainZone: props.domainZone,
      healthCheckGracePeriod: cdk.Duration.seconds(60),
      assignPublicIp: false
    });

    // Auto-scaling
    const scaling = service.service.autoScaleTaskCount({
      minCapacity: props.autoScaling.minCapacity,
      maxCapacity: props.autoScaling.maxCapacity
    });

    scaling.scaleOnCpuUtilization('CpuScaling', {
      targetUtilizationPercent: props.autoScaling.targetCpuUtilization,
      scaleInCooldown: cdk.Duration.seconds(60),
      scaleOutCooldown: cdk.Duration.seconds(60)
    });
  }
}
```

**Secrets Manager Configuration:**
```typescript
// lib/stacks/base-stack.ts
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';

const dbSecret = new secretsmanager.Secret(this, 'DbSecret', {
  description: 'RDS PostgreSQL master password',
  generateSecretString: {
    secretStringTemplate: JSON.stringify({ username: 'postgres' }),
    generateStringKey: 'password',
    excludeCharacters: ' %+~`#$&*()|[]{}:;<>?!\'/@"\\',
    passwordLength: 32
  }
});

// Automatic rotation
dbSecret.addRotationSchedule('DbSecretRotation', {
  automaticallyAfter: cdk.Duration.days(30),
  lambda: new lambda.Function(this, 'RotationLambda', {
    runtime: lambda.Runtime.NODEJS_18_X,
    handler: 'index.handler',
    code: lambda.Code.fromAsset('lambda/secret-rotation')
  })
});
```

### Testing Requirements

**CDK Testing Approach:**
```typescript
// infrastructure/test/unit/network-stack.test.ts
import { Template } from 'aws-cdk-lib/assertions';
import * as cdk from 'aws-cdk-lib';
import { NetworkStack } from '../lib/stacks/network-stack';

describe('NetworkStack', () => {
  test('should create VPC with correct configuration', () => {
    const app = new cdk.App();
    const stack = new NetworkStack(app, 'TestStack', {
      config: mockDevConfig
    });

    const template = Template.fromStack(stack);

    // Verify VPC exists
    template.hasResourceProperties('AWS::EC2::VPC', {
      CidrBlock: '10.0.0.0/16',
      EnableDnsHostnames: true,
      EnableDnsSupport: true
    });

    // Verify subnets
    template.resourceCountIs('AWS::EC2::Subnet', 6); // 3 AZs * 2 subnet types

    // Verify NAT Gateways
    template.resourceCountIs('AWS::EC2::NatGateway', 1); // Dev = 1 NAT
  });
});
```

**Infrastructure Testing Requirements:**
- Unit test coverage: >90% for all CDK constructs
- Integration tests for cross-stack references
- Snapshot tests for template validation
- Cost estimation tests for resource sizing
- Security compliance tests for IAM policies
- Network isolation tests for VPC configuration

## Definition of Done Checklist

### Development Complete
- [ ] All tests written BEFORE implementation (TDD followed)
- [ ] All acceptance criteria have corresponding tests
- [ ] All acceptance criteria implemented
- [ ] Unit tests written and passing (>90% coverage)
- [ ] Integration tests cover new functionality (>80% coverage)
- [ ] CDK synthesis successful for all environments
- [ ] Code follows AWS CDK best practices
- [ ] TypeScript types properly defined
- [ ] Infrastructure documentation updated

### Infrastructure Complete
- [ ] All infrastructure changes implemented in CDK
- [ ] IAM permissions validated (principle of least privilege)
- [ ] VPC and networking properly configured
- [ ] RDS instances deployed with proper configuration
- [ ] ElastiCache clusters operational
- [ ] ECS/Fargate services deployable
- [ ] S3 buckets created with policies
- [ ] CloudFront distributions configured
- [ ] Secrets Manager integrated
- [ ] CloudWatch alarms and dashboards updated
- [ ] Cost analysis completed for new resources

### Review Ready
- [ ] PR created with detailed description
- [ ] Code review completed by team
- [ ] Infrastructure review completed
- [ ] Security review passed
- [ ] Documentation updated (README, deployment guides)
- [ ] Deployment instructions documented
- [ ] Runbook updated for operations team

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-29 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Implementation Approach
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### Files Changed
_To be populated by dev agent_

### Deployment Notes
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_