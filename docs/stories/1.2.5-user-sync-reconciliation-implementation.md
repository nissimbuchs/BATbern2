# Story 1.2.5: User Sync and Reconciliation Implementation

## Status

Accepted

## Story

**As a** system administrator,
**I want** automatic user synchronization between AWS Cognito and the PostgreSQL database,
**so that** user data remains consistent across authentication and application storage, enabling reliable role-based access control and comprehensive audit trails.

## Domain Context

### Primary Domain

**Shared/Infrastructure** (Cross-cutting concern)

This story implements core infrastructure patterns that affect all domains:
- Event Management Domain (Organizer workflows)
- Speaker Coordination Domain (Speaker portal & workflows)
- Partner Analytics Domain (ROI tracking & strategic input)
- Attendee Experience Domain (Content discovery & registration)

### Involved Services

All microservices depend on this infrastructure:
- **API Gateway** - JWT validation, authentication
- **Event Management Service** - User role validation for organizers
- **Speaker Coordination Service** - Speaker user management
- **Partner Analytics Service** - Partner user management
- **Attendee Experience Service** - Attendee user management
- **Shared Kernel** - Common user sync patterns, JIT provisioning interceptor
- **AWS Lambda Functions** - Cognito trigger handlers (PostConfirmation, PreTokenGeneration, PreAuthentication)

### Cross-Domain Dependencies

**Dependencies:**
- **AWS Cognito** - Authentication, email verification, MFA, custom attributes
- **PostgreSQL** - User records, role history, audit trails
- **AWS Lambda** - Trigger handlers for user lifecycle events
- **EventBridge** - Domain events for user creation/updates (for cross-service notification)
- **CloudWatch** - Metrics, alarms, monitoring for sync health
- **Secrets Manager** - Database credentials for Lambda triggers

**Integration Points:**
- All services consume user data from shared `users` table
- All services rely on role sync for authorization
- EventBridge publishes `UserCreated`, `UserRoleChanged` events

## Requirements Context

### Related Functional Requirements

**From prd-enhanced.md:**
- **FR1** - Multi-role authentication system (ORGANIZER, SPEAKER, PARTNER, ATTENDEE)
- **FR2** - Role-based access control across 16-step workflow
- **FR17** - User audit trails and role change history
- **NFR3** - System availability and resilience (99.9% uptime)
- **NFR5** - Data consistency and integrity

### Workflow Steps (if applicable)

**Cross-cutting concern** - Affects all 16 workflow steps:
- Steps 1-16: All require reliable role-based authorization
- Step 2: Speaker user creation and role assignment
- Step 4: Partner user creation and role assignment
- Step 13: Attendee user creation and role assignment

### Acceptance Criteria Source

New foundational requirement for user lifecycle management. Acceptance criteria derived from:
- AWS Cognito best practices documentation
- BATbern architectural decision to use dual storage (Cognito + PostgreSQL)
- Operational requirements for environment bootstrapping (dev/staging/prod)

## Architecture Context

### Architecture Patterns

**Reference:** `docs/architecture/06-backend-architecture.md` (lines 1325-2427 - User Lifecycle and Sync Patterns)

**Patterns Implemented:**
1. **Event-Driven Sync** - AWS Cognito Lambda triggers (PostConfirmation, PreTokenGeneration, PreAuthentication)
2. **Just-In-Time Provisioning** - Spring Boot HandlerInterceptor for self-healing
3. **Saga Pattern** - Bidirectional role sync with compensation logic
4. **Scheduled Reconciliation** - Daily drift detection and automatic correction

**Reference:** `docs/architecture/03-data-architecture.md` (lines 1386-1551 - User Roles Schema)

**Data Models:**
- `users` table - Core user records linked to Cognito
- `user_roles` table - Role history with temporal tracking
- `user_sync_compensation_log` table - Saga compensation tracking

**Reference:** `docs/architecture/02-infrastructure-deployment.md`

**Infrastructure:**
- CDK stacks for Lambda triggers
- VPC configuration for database access from Lambda
- IAM roles for Cognito trigger execution

### Infrastructure Components

**Lambda Functions:**
- **PostConfirmationTrigger** - Runtime: Node.js 18.x, Trigger: Cognito PostConfirmation, Timeout: 10s
- **PreTokenGenerationTrigger** - Runtime: Node.js 18.x, Trigger: Cognito PreTokenGeneration, Timeout: 5s
- **PreAuthenticationTrigger** - Runtime: Node.js 18.x, Trigger: Cognito PreAuthentication, Timeout: 5s

**API Gateway:**
- No direct API Gateway changes
- All authenticated endpoints benefit from JIT provisioning interceptor

**Database:**
- **Table:** `user_sync_compensation_log`
- **Indexes:** `idx_compensation_status`, `idx_compensation_user`
- **Relations:** Foreign key to `users(id)`

**EventBridge:**
- Event Type: `UserCreated` - Published on JIT provisioning or PostConfirmation
- Event Type: `UserRoleChanged` - Published on role sync completion
- Targets: All microservices for cache invalidation

**ElastiCache:**
- Cache Key: `user:{cognitoId}` - User record cache, TTL: 15 minutes
- Cache Key: `user:roles:{userId}` - Active roles cache, TTL: 5 minutes
- Invalidation: On role change events

**CloudWatch:**
- Metrics Namespace: `BATbern/UserSync`
- Metrics: `SyncLatency`, `SyncFailures`, `DriftDetected`, `ReconciliationDuration`
- Alarms: `HighSyncFailureRate`, `HighSyncLatency`, `ReconciliationDriftDetected`
- Dashboards: User sync health dashboard

## Wireframe Context

### Wireframe References

Not applicable - this is a backend infrastructure story with no UI components.

### UI Components

Not applicable - infrastructure only.

## Acceptance Criteria

1. **PostConfirmation trigger creates database user within 1 second**
   - When a user completes email verification in Cognito
   - Then a corresponding user record is created in the `users` table
   - And an initial role is assigned based on Cognito custom attribute `custom:batbern_role`
   - And the operation completes within 1 second (p95 latency)

2. **JIT provisioning creates missing users on first API request**
   - Given a user exists in Cognito but not in the database
   - When the user makes their first authenticated API request
   - Then the JIT interceptor automatically creates the user record
   - And assigns the initial role from JWT claims
   - And the API request continues normally without error

3. **Role changes sync bidirectionally between database and Cognito**
   - When an organizer promotes a user to a new role in the database
   - Then the role is synced to Cognito custom attribute `custom:batbern_role`
   - And if the Cognito sync fails, a compensation log entry is created
   - And the operation retries with exponential backoff (3 attempts)

4. **Reconciliation job runs daily and fixes drift automatically**
   - Given the reconciliation job runs at 2 AM daily
   - When drift is detected between Cognito and database
   - Then orphaned database users are marked inactive
   - And missing database users are created from Cognito
   - And role mismatches are fixed (database is source of truth)
   - And failed compensations are retried (up to 5 attempts total)

5. **Monitoring alerts fire on sync failures**
   - When sync failures exceed 10 per 5-minute window
   - Then a CloudWatch alarm fires and SNS notification is sent
   - When sync latency exceeds 5 seconds (average over 5 minutes)
   - Then a CloudWatch alarm fires and SNS notification is sent
   - When drift exceeds 50 users in daily reconciliation
   - Then a CloudWatch alarm fires and SNS notification is sent

6. **User deletion in Cognito marks database user inactive**
   - When a user is deleted from Cognito (admin action or user self-deletion)
   - Then the next reconciliation job detects the orphaned database user
   - And marks the user as inactive with reason "Cognito user not found during reconciliation"
   - And all user's roles are deactivated

7. **Bootstrap organizer creation works for all environments**
   - Given a new environment (dev/staging/prod) is deployed
   - When the CDK stack is deployed with bootstrap configuration
   - Then an initial organizer user `nissim@buchs.be` is created in Cognito
   - And the user is created with permanent password `******` (not temporary)
   - And a corresponding database user is created via PostConfirmation trigger
   - And the organizer role is assigned
   - And the user can log in immediately without password reset

8. **Saga pattern handles partial failures with compensation**
   - Given a role change operation starts
   - When the database update succeeds but Cognito sync fails
   - Then a compensation log entry is created with status "FAILED"
   - And `compensation_required` is set to true
   - And the database transaction commits (eventual consistency)
   - And the next reconciliation job retries the compensation
   - And on success, compensation status is updated to "COMPLETED"

## Test Specifications (TDD)

### Test Scenarios by Acceptance Criteria

**AC1 Tests: PostConfirmation Trigger**
- Test 1.1: `should_createUserInDatabase_when_cognitoPostConfirmationFires`
- Test 1.2: `should_assignInitialRole_when_customAttributePresent`
- Test 1.3: `should_defaultToAttendeeRole_when_customAttributeMissing`
- Test 1.4: `should_beIdempotent_when_triggeredMultipleTimes`
- Test 1.5: `should_completeWithinOneSecond_when_databaseConnectionHealthy`
- Test 1.6: `should_notBlockConfirmation_when_databaseUnavailable`

**AC2 Tests: JIT Provisioning**
- Test 2.1: `should_createUser_when_cognitoUserNotInDatabase`
- Test 2.2: `should_assignRoleFromJWT_when_jitProvisioningUser`
- Test 2.3: `should_continueRequest_when_jitProvisioningCompletes`
- Test 2.4: `should_skipProvisioning_when_userAlreadyExists`
- Test 2.5: `should_notBlockRequest_when_jitProvisioningFails`
- Test 2.6: `should_publishUserCreatedEvent_when_jitProvisioningSucceeds`

**AC3 Tests: Bidirectional Role Sync**
- Test 3.1: `should_syncToCognito_when_roleChangedInDatabase`
- Test 3.2: `should_createCompensationLog_when_cognitoSyncFails`
- Test 3.3: `should_retryWithBackoff_when_cognitoThrottles`
- Test 3.4: `should_markCompensationCompleted_when_syncSucceeds`
- Test 3.5: `should_notRollbackDatabase_when_cognitoSyncFails`

**AC4 Tests: Reconciliation Job**
- Test 4.1: `should_deactivateDbUser_when_cognitoUserNotFound`
- Test 4.2: `should_createDbUser_when_cognitoUserMissing`
- Test 4.3: `should_syncRoleToC ognito_when_roleMismatchDetected`
- Test 4.4: `should_retryFailedCompensations_when_reconciliationRuns`
- Test 4.5: `should_publishMetrics_when_reconciliationCompletes`
- Test 4.6: `should_handlePagination_when_manyUsersExist`

**AC5 Tests: Monitoring and Alerts**
- Test 5.1: `should_recordSyncLatencyMetric_when_syncCompletes`
- Test 5.2: `should_recordSyncFailureMetric_when_syncFails`
- Test 5.3: `should_fireAlarm_when_failureRateExceedsThreshold`
- Test 5.4: `should_fireAlarm_when_latencyExceedsThreshold`
- Test 5.5: `should_fireAlarm_when_driftExceedsThreshold`

**AC6 Tests: User Deletion Handling**
- Test 6.1: `should_markInactive_when_cognitoUserDeleted`
- Test 6.2: `should_deactivateRoles_when_userMarkedInactive`
- Test 6.3: `should_setDeactivationReason_when_cognitoUserNotFound`

**AC7 Tests: Bootstrap Organizer Creation**
- Test 7.1: `should_createBootstrapUser_when_stackDeployed`
- Test 7.2: `should_assignOrganizerRole_when_bootstrapUserCreated`
- Test 7.3: `should_setPermanentPassword_when_bootstrapUserCreated`
- Test 7.4: `should_allowImmediateLogin_when_bootstrapUserCreated`
- Test 7.5: `should_beIdempotent_when_stackDeployedMultipleTimes`

**AC8 Tests: Saga Compensation**
- Test 8.1: `should_createCompensationLog_when_sagaStarts`
- Test 8.2: `should_markFailed_when_cognitoSyncFails`
- Test 8.3: `should_retryCompensation_when_reconciliationRuns`
- Test 8.4: `should_incrementRetryCount_when_retryFails`
- Test 8.5: `should_stopRetrying_when_maxRetriesExceeded`

### Test File Locations

**Backend Tests:**

**Lambda Trigger Tests:**
- Unit: `infrastructure/lib/lambda/triggers/__tests__/post-confirmation.test.ts`
- Unit: `infrastructure/lib/lambda/triggers/__tests__/pre-token-generation.test.ts`
- Unit: `infrastructure/lib/lambda/triggers/__tests__/pre-authentication.test.ts`
- Integration: `infrastructure/lib/lambda/triggers/__tests__/integration/cognito-triggers.integration.test.ts`

**JIT Provisioning Tests:**
- Unit: `shared-kernel/src/test/unit/interceptor/JITUserProvisioningInterceptorTest.java`
- Integration: `shared-kernel/src/test/integration/interceptor/JITUserProvisioningInterceptorIntegrationTest.java`

**Saga Pattern Tests:**
- Unit: `shared-kernel/src/test/unit/service/UserSyncSagaServiceTest.java`
- Integration: `shared-kernel/src/test/integration/service/UserSyncSagaServiceIntegrationTest.java`

**Reconciliation Service Tests:**
- Unit: `shared-kernel/src/test/unit/service/UserReconciliationServiceTest.java`
- Integration: `shared-kernel/src/test/integration/service/UserReconciliationServiceIntegrationTest.java`

**Metrics Service Tests:**
- Unit: `shared-kernel/src/test/unit/service/UserSyncMetricsServiceTest.java`

**E2E Tests:**
- `e2e/workflows/user-sync/user-registration-sync.spec.ts`
- `e2e/workflows/user-sync/role-change-sync.spec.ts`
- `e2e/workflows/user-sync/reconciliation-drift-fix.spec.ts`

### Test Data & Mocks

**Test Data Builders:**
- `UserTestDataBuilder` - Create test users with various states (active, inactive, with/without roles)
- `CognitoUserTestDataBuilder` - Create mock Cognito user responses
- `UserRoleEntityTestDataBuilder` - Create test role entities with history
- `CompensationLogTestDataBuilder` - Create test compensation log entries

**Mock Services:**
- `MockAWSCognitoIdentityProvider` - Mock Cognito client for unit tests
- `MockPostgresDatabase` - In-memory database for Lambda trigger tests
- `MockCloudWatchClient` - Mock CloudWatch for metrics tests
- `MockSecretsManagerClient` - Mock Secrets Manager for credential tests

**Test Containers:**
- PostgreSQL 15 container for integration tests
- LocalStack container for AWS service mocks (Cognito, Secrets Manager, CloudWatch)

**Test Fixtures:**
- `cognito-user-confirmed.json` - Sample PostConfirmation event
- `cognito-user-token-generation.json` - Sample PreTokenGeneration event
- `cognito-user-pre-auth.json` - Sample PreAuthentication event
- `jwt-with-roles.json` - Sample JWT with custom claims

## Tasks / Subtasks (TDD Workflow)

- [x] Task 1: Write Lambda Trigger E2E Tests (RED Phase)
  - [x] Write failing E2E test for user registration ‚Üí DB creation flow
  - [x] Write failing E2E test for JWT token enrichment with DB roles
  - [x] Verify tests fail with meaningful errors

- [x] Task 2a: PostConfirmation Lambda TDD Tests (RED Phase) (AC: 1)
  - [x] Write failing unit tests for user creation logic
  - [x] Write failing unit tests for role assignment logic
  - [x] Write failing unit tests for idempotency (ON CONFLICT)
  - [x] Write failing unit tests for error handling (DB unavailable)
  - [x] Write failing integration test with PostgreSQL container

- [x] Task 2b: PostConfirmation Lambda TDD Implementation (GREEN Phase) (AC: 1)
  - [x] Implement PostConfirmation handler to make tests pass
  - [x] Implement database connection pooling
  - [x] Implement ON CONFLICT upsert logic
  - [x] Implement error logging without blocking Cognito

- [x] Task 3a: PreTokenGeneration Lambda TDD Tests (RED Phase) (AC: 1)
  - [x] Write failing unit tests for role fetching from DB
  - [x] Write failing unit tests for JWT claim enrichment
  - [x] Write failing unit tests for fallback on DB error
  - [x] Write failing integration test with PostgreSQL container

- [x] Task 3b: PreTokenGeneration Lambda TDD Implementation (GREEN Phase) (AC: 1)
  - [x] Implement PreTokenGeneration handler to make tests pass
  - [x] Implement role query with event-specific roles
  - [x] Implement JWT claims override logic
  - [x] Implement graceful degradation on errors

- [ ] Task 4a: PreAuthentication Lambda TDD Tests (RED Phase) (AC: 6)
  - [ ] Write failing unit tests for user active status check
  - [ ] Write failing unit tests for blocking inactive users
  - [ ] Write failing unit tests for allowing JIT provisioning path
  - [ ] Write failing integration test with PostgreSQL container

- [ ] Task 4b: PreAuthentication Lambda TDD Implementation (GREEN Phase) (AC: 6)
  - [ ] Implement PreAuthentication handler to make tests pass
  - [ ] Implement user active status validation
  - [ ] Implement error throwing to block authentication
  - [ ] Implement JIT provisioning allowance logic

- [ ] Task 5a: JIT Provisioning Interceptor TDD Tests (RED Phase) (AC: 2)
  - [ ] Write failing unit tests for user existence check
  - [ ] Write failing unit tests for automatic user creation
  - [ ] Write failing unit tests for role assignment from JWT
  - [ ] Write failing unit tests for request continuation
  - [ ] Write failing unit tests for error handling (non-blocking)
  - [ ] Write failing integration test with Spring Boot test context

- [ ] Task 5b: JIT Provisioning Interceptor TDD Implementation (GREEN Phase) (AC: 2)
  - [ ] Implement HandlerInterceptor interface
  - [ ] Implement user existence check logic
  - [ ] Implement automatic user creation with transaction
  - [ ] Implement role extraction from SecurityContext
  - [ ] Implement event publishing for observability
  - [ ] Implement error handling without blocking requests

- [ ] Task 6a: Saga Pattern Service TDD Tests (RED Phase) (AC: 3, 8)
  - [ ] Write failing unit tests for compensation log creation
  - [ ] Write failing unit tests for Cognito sync with retry
  - [ ] Write failing unit tests for compensation on failure
  - [ ] Write failing unit tests for exponential backoff
  - [ ] Write failing integration test with Resilience4j retry

- [ ] Task 6b: Saga Pattern Service TDD Implementation (GREEN Phase) (AC: 3, 8)
  - [ ] Implement UserSyncSagaService with compensation logic
  - [ ] Implement Resilience4j retry configuration
  - [ ] Implement compensation log persistence
  - [ ] Implement Cognito sync with AdminUpdateUserAttributes
  - [ ] Implement error handling and alert emission

- [ ] Task 7a: Reconciliation Service TDD Tests (RED Phase) (AC: 4, 6)
  - [ ] Write failing unit tests for orphaned DB user detection
  - [ ] Write failing unit tests for missing DB user creation
  - [ ] Write failing unit tests for role mismatch detection
  - [ ] Write failing unit tests for compensation retry logic
  - [ ] Write failing unit tests for pagination handling
  - [ ] Write failing integration test with LocalStack Cognito mock

- [ ] Task 7b: Reconciliation Service TDD Implementation (GREEN Phase) (AC: 4, 6)
  - [ ] Implement scheduled job with @Scheduled annotation
  - [ ] Implement reconcileOrphanedDbUsers method
  - [ ] Implement reconcileMissingDbUsers method with pagination
  - [ ] Implement reconcileRoleMismatches method (DB as source of truth)
  - [ ] Implement retryFailedCompensations method
  - [ ] Implement ReconciliationReport generation

- [ ] Task 8a: Metrics and Alarms TDD Tests (RED Phase) (AC: 5)
  - [ ] Write failing unit tests for metric recording
  - [ ] Write failing unit tests for alarm threshold detection
  - [ ] Write failing integration test with CloudWatch SDK

- [ ] Task 8b: Metrics and Alarms TDD Implementation (GREEN Phase) (AC: 5)
  - [ ] Implement UserSyncMetricsService with CloudWatch client
  - [ ] Implement recordSyncLatency method
  - [ ] Implement recordSyncFailure method
  - [ ] Implement recordDriftDetected method
  - [ ] Create CDK constructs for CloudWatch alarms
  - [ ] Create SNS topic for alarm notifications

- [x] Task 9a: Bootstrap Organizer TDD Tests (RED Phase) (AC: 7)
  - [x] Write failing unit tests for bootstrap user creation
  - [x] Write failing unit tests for permanent password assignment
  - [x] Write failing integration test with CDK stack deployment

- [x] Task 9b: Bootstrap Organizer TDD Implementation (GREEN Phase) (AC: 7)
  - [x] Create CDK construct for bootstrap user creation
  - [x] Implement AdminCreateUser with permanent password (MessageAction: SUPPRESS)
  - [x] Configure user: `nissim@buchs.be`, password: `******`
  - [x] Set email_verified to true to skip verification
  - [x] Implement idempotency (check if user exists first)
  - [x] Add custom attribute `custom:batbern_role = ORGANIZER`

- [ ] Task 10: Infrastructure Setup
  - [ ] Create Lambda trigger CDK constructs in auth-stack.ts
  - [ ] Configure VPC subnets for Lambda database access
  - [ ] Create IAM roles for Lambda execution
  - [ ] Grant Lambda access to Secrets Manager
  - [ ] Grant Lambda access to database via security groups
  - [ ] Create EventBridge rules for user sync events
  - [ ] Create CloudWatch dashboard for user sync metrics
  - [ ] Deploy and test in dev environment

- [ ] Task 11: Database Migration
  - [ ] Create migration for user_sync_compensation_log table
  - [ ] Create indexes on compensation log (status, user_id)
  - [ ] Add unique constraint on users(cognito_id) if missing
  - [ ] Test migration rollback

- [ ] Task 12: Integration Testing
  - [ ] Test full user registration flow (Cognito ‚Üí PostConfirmation ‚Üí DB)
  - [ ] Test JWT token generation with DB role enrichment
  - [ ] Test JIT provisioning on first API request
  - [ ] Test role change sync (DB ‚Üí Cognito)
  - [ ] Test reconciliation job execution
  - [ ] Test alarm triggering on failures
  - [ ] Test bootstrap user creation on new environment

- [ ] Task 13: Backend and Frontend Refactoring (REFACTOR)
  - [ ] Verify all E2E tests pass (GREEN)
  - [ ] Optimize database queries with connection pooling
  - [ ] Add caching for user lookups (ElastiCache)
  - [ ] Refactor Lambda triggers to share common database connection logic
  - [ ] Add structured logging with correlation IDs
  - [ ] Add performance monitoring with X-Ray
  - [ ] Refactor Java services to use common UserSyncService abstraction
  - [ ] Add debug logging for troubleshooting sync issues

## Dev Notes - Implementation Guide

### Service Setup

**Lambda Trigger Locations:**
- `infrastructure/lib/lambda/triggers/post-confirmation.ts`
- `infrastructure/lib/lambda/triggers/pre-token-generation.ts`
- `infrastructure/lib/lambda/triggers/pre-authentication.ts`
- `infrastructure/lib/lambda/triggers/common/database.ts` (shared connection logic)

**Java Service Locations:**
- `shared-kernel/src/main/java/ch/batbern/shared/interceptor/JITUserProvisioningInterceptor.java`
- `shared-kernel/src/main/java/ch/batbern/shared/service/UserSyncSagaService.java`
- `shared-kernel/src/main/java/ch/batbern/shared/service/UserReconciliationService.java`
- `shared-kernel/src/main/java/ch/batbern/shared/service/UserSyncMetricsService.java`
- `shared-kernel/src/main/java/ch/batbern/shared/repository/UserSyncCompensationLogRepository.java`
- `shared-kernel/src/main/java/ch/batbern/shared/domain/UserSyncCompensationLog.java`

**CDK Infrastructure Locations:**
- `infrastructure/lib/stacks/auth-stack.ts` (existing - add trigger configuration)
- `infrastructure/lib/constructs/cognito-user-sync.ts` (new - sync infrastructure)
- `infrastructure/lib/constructs/bootstrap-organizer.ts` (new - bootstrap user creation)
- `infrastructure/lib/monitoring/user-sync-alarms.ts` (new - CloudWatch alarms)

### Technical Design Notes

**Design Patterns:**
1. **Event-Driven Architecture** - Cognito triggers drive DB sync
2. **Saga Pattern** - Compensation-based transactions for distributed updates
3. **Interceptor Pattern** - JIT provisioning via Spring HandlerInterceptor
4. **Scheduled Job Pattern** - Daily reconciliation with cron expression
5. **Retry Pattern** - Resilience4j exponential backoff for Cognito API calls
6. **Circuit Breaker Pattern** - Prevent cascading failures on Cognito unavailability

**Service Method Signatures:**

```java
// UserSyncSagaService.java
public void syncRoleChangeToCognito(UUID userId, UserRole newRole, String cognitoId);
private void updateCognitoUserAttribute(String cognitoId, UserRole role);
private void emitSyncFailureAlert(UUID userId, String cognitoId, UserRole role, Exception error);

// UserReconciliationService.java
@Scheduled(cron = "0 0 2 * * *")
public void reconcileUsers();
private void reconcileOrphanedDbUsers(ReconciliationReport report);
private void reconcileMissingDbUsers(ReconciliationReport report);
private void reconcileRoleMismatches(ReconciliationReport report);
private void retryFailedCompensations(ReconciliationReport report);

// JITUserProvisioningInterceptor.java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler);
private void publishUserCreatedEvent(User user, String role);

// UserSyncMetricsService.java
public void recordSyncLatency(String syncType, long latencyMs);
public void recordSyncFailure(String syncType);
public void recordDriftDetected(int driftCount);
```

**Database Transaction Boundaries:**
- Lambda triggers: Each trigger execution is a single transaction
- JIT provisioning: Entire interceptor logic in @Transactional method
- Saga pattern: DB update and compensation log in same transaction, Cognito sync outside
- Reconciliation: Each reconciliation phase (orphaned, missing, mismatches) in separate transactions

**Caching Strategies:**
- Cache user records in ElastiCache with 15-minute TTL
- Cache role assignments with 5-minute TTL
- Invalidate cache on EventBridge `UserRoleChanged` event
- No caching for Lambda triggers (real-time requirement)

**Error Handling Patterns:**
- Lambda triggers: Log errors, don't throw (allow Cognito operation to continue)
- JIT provisioning: Catch all exceptions, log, allow request to continue
- Saga pattern: Log compensation required, emit alert, commit DB transaction
- Reconciliation: Continue on individual user failures, log aggregate metrics

**Performance Considerations:**
- Lambda trigger timeout: 10s for PostConfirmation, 5s for PreToken/PreAuth
- Database connection pooling in Lambda (reuse across invocations)
- Batch size for Cognito ListUsers: 60 (max allowed)
- Reconciliation pagination to avoid memory issues with large user bases
- Index on user_sync_compensation_log(status, compensation_required) for fast lookups

### API Contracts

**PostConfirmation Lambda Event:**

```json
{
  "version": "1",
  "triggerSource": "PostConfirmation_ConfirmSignUp",
  "region": "eu-central-1",
  "userPoolId": "eu-central-1_XXXXXXXXX",
  "userName": "a1b2c3d4-5678-90ab-cdef-EXAMPLE11111",
  "request": {
    "userAttributes": {
      "sub": "a1b2c3d4-5678-90ab-cdef-EXAMPLE11111",
      "cognito:email_alias": "user@example.com",
      "cognito:user_status": "CONFIRMED",
      "email_verified": "true",
      "email": "user@example.com",
      "custom:batbern_role": "ORGANIZER"
    }
  },
  "response": {}
}
```

**PreTokenGeneration Lambda Response:**

```json
{
  "response": {
    "claimsOverrideDetails": {
      "claimsToAddOrOverride": {
        "custom:batbern_roles": "[\"ORGANIZER\",\"SPEAKER\"]",
        "custom:batbern_event_roles": "[{\"eventId\":\"evt-123\",\"role\":\"SPEAKER\"}]",
        "custom:roles_synced_at": "2025-10-08T12:34:56.789Z"
      }
    }
  }
}
```

**UserCreated EventBridge Event:**

```json
{
  "version": "0",
  "id": "evt-123",
  "detail-type": "UserCreated",
  "source": "ch.batbern.user-sync",
  "account": "123456789012",
  "time": "2025-10-08T12:34:56Z",
  "region": "eu-central-1",
  "resources": [],
  "detail": {
    "userId": "a1b2c3d4-5678-90ab-cdef-EXAMPLE11111",
    "cognitoId": "cognito-user-id",
    "email": "user@example.com",
    "role": "ORGANIZER",
    "createdAt": "2025-10-08T12:34:56.789Z",
    "source": "JIT_PROVISIONING"
  }
}
```

**Compensation Log Entity:**

```java
@Entity
@Table(name = "user_sync_compensation_log")
@Data
@Builder
public class UserSyncCompensationLog {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(name = "user_id", nullable = false)
    private UUID userId;

    @Column(name = "cognito_id", nullable = false, length = 255)
    private String cognitoId;

    @Column(name = "operation", nullable = false, length = 50)
    private String operation; // ROLE_SYNC, USER_CREATE, USER_DELETE

    @Column(name = "target_role", length = 50)
    @Enumerated(EnumType.STRING)
    private UserRole targetRole;

    @Column(name = "status", nullable = false, length = 20)
    private String status; // PENDING, COMPLETED, FAILED

    @Column(name = "attempted_at", nullable = false)
    private Instant attemptedAt;

    @Column(name = "completed_at")
    private Instant completedAt;

    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    @Column(name = "compensation_required")
    private Boolean compensationRequired = false;

    @Column(name = "compensation_executed_at")
    private Instant compensationExecutedAt;

    @Column(name = "retry_count")
    private Integer retryCount = 0;
}
```

### Database Schema

**Migration: V1_005__Create_User_Sync_Compensation_Log.sql**

```sql
-- Create user sync compensation log table
CREATE TABLE user_sync_compensation_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    cognito_id VARCHAR(255) NOT NULL,
    operation VARCHAR(50) NOT NULL,
    target_role VARCHAR(50),
    status VARCHAR(20) NOT NULL,
    attempted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    compensation_required BOOLEAN DEFAULT false,
    compensation_executed_at TIMESTAMP,
    retry_count INTEGER DEFAULT 0,

    CONSTRAINT chk_status CHECK (status IN ('PENDING', 'COMPLETED', 'FAILED')),
    CONSTRAINT chk_operation CHECK (operation IN ('ROLE_SYNC', 'USER_CREATE', 'USER_DELETE'))
);

-- Indexes for fast lookups
CREATE INDEX idx_compensation_status ON user_sync_compensation_log(status, compensation_required)
    WHERE compensation_required = true;
CREATE INDEX idx_compensation_user ON user_sync_compensation_log(user_id);
CREATE INDEX idx_compensation_cognito ON user_sync_compensation_log(cognito_id);

-- Add comment
COMMENT ON TABLE user_sync_compensation_log IS 'Tracks saga compensation operations for user sync failures';
```

**Ensure unique constraint on users table:**

```sql
-- Add unique constraint on cognito_id if not exists
ALTER TABLE users ADD CONSTRAINT uk_users_cognito_id UNIQUE (cognito_id);
```

### React Components

Not applicable - this is a backend infrastructure story.

### Integration Code

**EventBridge Event Publishing:**

```java
@Service
@RequiredArgsConstructor
public class UserSyncEventPublisher {

    private final EventBridgeClient eventBridgeClient;

    @Value("${aws.eventbridge.bus-name}")
    private String eventBusName;

    public void publishUserCreatedEvent(User user, String role, String source) {
        PutEventsRequestEntry event = PutEventsRequestEntry.builder()
            .eventBusName(eventBusName)
            .source("ch.batbern.user-sync")
            .detailType("UserCreated")
            .detail(createUserCreatedDetail(user, role, source))
            .build();

        PutEventsRequest request = PutEventsRequest.builder()
            .entries(event)
            .build();

        eventBridgeClient.putEvents(request);
    }

    private String createUserCreatedDetail(User user, String role, String source) {
        return String.format("""
            {
              "userId": "%s",
              "cognitoId": "%s",
              "email": "%s",
              "role": "%s",
              "createdAt": "%s",
              "source": "%s"
            }
            """,
            user.getId(),
            user.getCognitoId(),
            user.getEmail(),
            role,
            user.getCreatedAt(),
            source
        );
    }
}
```

### Configuration

**Environment Variables:**

**Lambda Functions:**
```bash
DB_HOST=batbern-db.cluster-xxxx.eu-central-1.rds.amazonaws.com
DB_NAME=batbern
DB_USER=batbern_app
DB_PASSWORD=${SECRET:batbern/database/credentials:password}
LOG_LEVEL=INFO
```

**Spring Boot Services:**
```yaml
# application.yml
aws:
  cognito:
    user-pool-id: ${COGNITO_USER_POOL_ID}
    region: eu-central-1
  eventbridge:
    bus-name: batbern-event-bus

spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST}:5432/${DB_NAME}
    username: ${DB_USER}
    password: ${DB_PASSWORD}

  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

scheduling:
  enabled: true

resilience4j:
  retry:
    instances:
      cognito-sync:
        maxAttempts: 3
        waitDuration: 2s
        exponentialBackoffMultiplier: 2
        retryExceptions:
          - com.amazonaws.services.cognitoidentityprovider.model.TooManyRequestsException
          - com.amazonaws.services.cognitoidentityprovider.model.InternalErrorException
```

**CDK Context:**
```json
{
  "bootstrap-organizer": {
    "email": "nissim@buchs.be",
    "password": "******",
    "role": "ORGANIZER"
  }
}
```

**Note:** This bootstrap configuration creates the same organizer user across all environments (dev/staging/prod). For production deployments, consider using environment-specific credentials stored in AWS Secrets Manager for enhanced security.

### Code Patterns

**Resilience4j Retry Configuration:**

```java
@Configuration
public class Resilience4jConfig {

    @Bean
    public RetryConfig cognitoRetryConfig() {
        return RetryConfig.custom()
            .maxAttempts(3)
            .waitDuration(Duration.ofSeconds(2))
            .exponentialBackoffMultiplier(2.0)
            .retryExceptions(
                TooManyRequestsException.class,
                InternalErrorException.class
            )
            .ignoreExceptions(
                UserNotFoundException.class,
                InvalidParameterException.class
            )
            .build();
    }

    @Bean
    public Retry cognitoRetry(RetryConfig cognitoRetryConfig) {
        return Retry.of("cognito-sync", cognitoRetryConfig);
    }
}
```

**Bootstrap Organizer CDK Construct:**

```typescript
// infrastructure/lib/constructs/bootstrap-organizer.ts
import * as cognito from 'aws-cdk-lib/aws-cognito';
import * as customResources from 'aws-cdk-lib/custom-resources';
import * as logs from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';

export interface BootstrapOrganizerProps {
  userPool: cognito.IUserPool;
  email: string;
  password: string;
}

export class BootstrapOrganizer extends Construct {
  constructor(scope: Construct, id: string, props: BootstrapOrganizerProps) {
    super(scope, id);

    // Create bootstrap organizer user via custom resource
    const createUserCustomResource = new customResources.AwsCustomResource(
      this,
      'CreateBootstrapUser',
      {
        onCreate: {
          service: 'CognitoIdentityServiceProvider',
          action: 'adminCreateUser',
          parameters: {
            UserPoolId: props.userPool.userPoolId,
            Username: props.email,
            MessageAction: 'SUPPRESS', // Don't send welcome email
            TemporaryPassword: props.password,
            UserAttributes: [
              {
                Name: 'email',
                Value: props.email,
              },
              {
                Name: 'email_verified',
                Value: 'true',
              },
              {
                Name: 'custom:batbern_role',
                Value: 'ORGANIZER',
              },
            ],
          },
          physicalResourceId: customResources.PhysicalResourceId.of(
            `bootstrap-organizer-${props.email}`
          ),
        },
        onUpdate: {
          // Idempotent - only create if doesn't exist
          service: 'CognitoIdentityServiceProvider',
          action: 'adminGetUser',
          parameters: {
            UserPoolId: props.userPool.userPoolId,
            Username: props.email,
          },
          physicalResourceId: customResources.PhysicalResourceId.of(
            `bootstrap-organizer-${props.email}`
          ),
          // Ignore error if user doesn't exist (will be created)
          ignoreErrorCodesMatching: 'UserNotFoundException',
        },
        policy: customResources.AwsCustomResourcePolicy.fromSdkCalls({
          resources: customResources.AwsCustomResourcePolicy.ANY_RESOURCE,
        }),
        logRetention: logs.RetentionDays.ONE_WEEK,
      }
    );

    // Set permanent password (removes temporary status)
    const setPermanentPassword = new customResources.AwsCustomResource(
      this,
      'SetPermanentPassword',
      {
        onCreate: {
          service: 'CognitoIdentityServiceProvider',
          action: 'adminSetUserPassword',
          parameters: {
            UserPoolId: props.userPool.userPoolId,
            Username: props.email,
            Password: props.password,
            Permanent: true, // Make password permanent
          },
          physicalResourceId: customResources.PhysicalResourceId.of(
            `bootstrap-password-${props.email}`
          ),
        },
        policy: customResources.AwsCustomResourcePolicy.fromSdkCalls({
          resources: customResources.AwsCustomResourcePolicy.ANY_RESOURCE,
        }),
        logRetention: logs.RetentionDays.ONE_WEEK,
      }
    );

    // Ensure password is set after user creation
    setPermanentPassword.node.addDependency(createUserCustomResource);
  }
}
```

**Usage in AuthStack:**

```typescript
// infrastructure/lib/stacks/auth-stack.ts
import { BootstrapOrganizer } from '../constructs/bootstrap-organizer';

export class AuthStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, props);

    // ... existing userPool creation ...

    // Create bootstrap organizer
    const bootstrapConfig = this.node.tryGetContext('bootstrap-organizer');

    if (bootstrapConfig) {
      new BootstrapOrganizer(this, 'BootstrapOrganizer', {
        userPool: userPool,
        email: bootstrapConfig.email,
        password: bootstrapConfig.password,
      });
    }
  }
}
```

**Lambda Database Connection Reuse:**

```typescript
// infrastructure/lib/lambda/triggers/common/database.ts
import { Client, Pool } from 'pg';

// Connection pool persists across Lambda invocations
let pool: Pool | null = null;

export async function getDbClient(): Promise<Client> {
  if (!pool) {
    pool = new Pool({
      host: process.env.DB_HOST,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      port: 5432,
      ssl: { rejectUnauthorized: true },
      max: 2, // Low max for Lambda (one concurrent execution per container)
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 5000,
    });
  }

  return pool.connect();
}

export async function closePool(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = null;
  }
}
```

### Testing Patterns

**Integration Test Base Class:**

```java
@SpringBootTest
@Testcontainers
@ActiveProfiles("test")
public abstract class UserSyncIntegrationTestBase {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("batbern_test")
        .withUsername("test")
        .withPassword("test");

    @Container
    static LocalStackContainer localstack = new LocalStackContainer(DockerImageName.parse("localstack/localstack:latest"))
        .withServices(LocalStackContainer.Service.COGNITO, LocalStackContainer.Service.SECRETSMANAGER);

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);

        registry.add("aws.cognito.endpoint",
            () -> localstack.getEndpointOverride(LocalStackContainer.Service.COGNITO).toString());
        registry.add("aws.region", () -> localstack.getRegion());
    }

    @Autowired
    protected UserRepository userRepository;

    @Autowired
    protected UserRoleRepository userRoleRepository;

    @Autowired
    protected UserSyncCompensationLogRepository compensationLogRepository;

    @BeforeEach
    void setUp() {
        // Clean database before each test
        compensationLogRepository.deleteAll();
        userRoleRepository.deleteAll();
        userRepository.deleteAll();
    }
}
```

**Test Coverage Requirements:**
- Unit tests: >90% coverage for service logic
- Integration tests: >80% coverage for sync flows
- E2E tests: All critical user journeys (registration, role change, reconciliation)

## Definition of Done Checklist

### Development Complete

- [ ] All tests written BEFORE implementation (TDD followed)
- [ ] All acceptance criteria have corresponding tests
- [ ] All acceptance criteria implemented
- [ ] Unit tests written and passing (>90% coverage)
- [ ] Integration tests cover new functionality (>80% coverage)
- [ ] E2E tests pass for user journeys
- [ ] Code follows project conventions (Java + TypeScript)
- [ ] TypeScript types properly defined for Lambda handlers
- [ ] API documentation updated (EventBridge event schemas)
- [ ] Database migrations created and tested (up + down)

### Infrastructure Complete ‚ö†Ô∏è CRITICAL

- [ ] Lambda trigger CDK constructs implemented in auth-stack.ts
- [ ] IAM permissions validated (principle of least privilege)
  - [ ] Lambda execution role for database access
  - [ ] Lambda execution role for Secrets Manager read
  - [ ] Cognito service role for trigger invocation
- [ ] Lambda functions deployed with proper configs (VPC, timeout, memory)
- [ ] Database migrations applied successfully (dev environment)
- [ ] EventBridge rules configured for UserCreated events
- [ ] CloudWatch alarms and dashboards created
- [ ] SNS topic created for alarm notifications
- [ ] Cost analysis completed (Lambda invocations, CloudWatch metrics, RDS connections)

### Backend Complete

- [ ] PostConfirmation Lambda trigger implemented and tested
- [ ] PreTokenGeneration Lambda trigger implemented and tested
- [ ] PreAuthentication Lambda trigger implemented and tested
- [ ] JITUserProvisioningInterceptor registered in WebMvcConfiguration
- [ ] UserSyncSagaService integrated into RoleManagementService
- [ ] UserReconciliationService scheduled job enabled
- [ ] UserSyncMetricsService recording all metrics
- [ ] EventBridge event publishing working for user creation
- [ ] ElastiCache integration for user caching implemented
- [ ] Error handling and logging comprehensive

### Frontend Complete (if applicable)

Not applicable - this is a backend infrastructure story.

### Review Ready

- [ ] PR created with detailed description
  - [ ] Overview of sync patterns implemented
  - [ ] Architecture diagrams (sequence diagrams for each pattern)
  - [ ] Testing strategy explanation
  - [ ] Deployment order (migrations ‚Üí CDK stack ‚Üí code)
- [ ] Code review completed by team
- [ ] Infrastructure review completed (CDK stack changes)
- [ ] Security review passed (IAM policies, Secrets Manager usage)
- [ ] Documentation updated
  - [ ] `docs/architecture/06-backend-architecture.md` (already updated)
  - [ ] `docs/deployment/README.md` (add bootstrap user creation steps)
  - [ ] `docs/troubleshooting/user-sync.md` (new - troubleshooting guide)
- [ ] CLAUDE.md updated if commands changed (not applicable)
- [ ] Deployment instructions documented (runbook for prod deployment)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-08 | 1.0 | Initial story creation for user sync and reconciliation implementation | Winston (Architect Agent) |

## Dev Agent Record

### Agent Model Used

**Model:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
**Agent Persona:** James - Full Stack Developer üíª
**Date:** 2025-10-08

### Implementation Approach

**Test-Driven Development (TDD) Workflow:**
1. **RED Phase:** Wrote 28 comprehensive failing tests covering all acceptance criteria
2. **GREEN Phase:** Implemented PreTokenGeneration handler to make all tests pass
3. **Test Categories:**
   - Role Fetching (5 tests)
   - JWT Claim Enrichment (6 tests)
   - Error Handling & Fallback (6 tests)
   - Performance (3 tests)
   - Trigger Sources (3 tests)
   - CloudWatch Metrics (3 tests)
   - Role Deduplication (2 tests)

**Key Implementation Decisions:**
- Used PoolClient instead of Client for proper connection release() method
- Implemented graceful degradation: DB errors result in empty roles (non-blocking)
- Separated global roles from event-specific roles in JWT claims
- Added role deduplication to handle duplicate database entries
- Used getDbClient() from common/database.ts for connection pooling
- Published CloudWatch metrics for observability (latency, failure count, role count)

### Debug Log References

_To be filled by dev agent during implementation_

### Completion Notes

**Tasks 1, 2a, 2b (PostConfirmation) - Completed Previously:**
- PostConfirmation Lambda handler fully implemented with tests
- All unit and integration tests passing

**Tasks 3a & 3b (PreTokenGeneration) - Completed:**
- Created 28 comprehensive unit tests following TDD RED phase
- Implemented PreTokenGeneration Lambda handler (GREEN phase)
- All 28 tests passing
- Features implemented:
  - Role fetching from database with JOIN on users table by cognito_id
  - Separation of global roles vs event-specific roles
  - JWT claims enrichment with custom:batbern_roles and custom:batbern_event_roles
  - Role deduplication for global roles
  - Graceful fallback to empty roles on database errors (non-blocking)
  - CloudWatch metrics (RoleFetchLatency, RoleCount, RoleFetchFailure)
  - Connection pooling via common/database.ts
  - Support for all trigger sources (Authentication, NewPasswordChallenge, RefreshTokens)

**Tasks 9a & 9b (Bootstrap Organizer) - Completed:**
- Created 8 comprehensive unit tests for bootstrap organizer construct (RED phase)
- Implemented BootstrapOrganizer CDK construct (GREEN phase)
- All 8 tests passing
- Features implemented:
  - AdminCreateUser custom resource for user creation
  - AdminSetUserPassword custom resource for permanent password
  - User attributes: email, email_verified=true, custom:role=organizer
  - MessageAction: SUPPRESS (no welcome email)
  - Idempotency via physicalResourceId and adminGetUser on update
  - Dependency chain: password setting depends on user creation
  - IAM roles and policies for custom resource Lambda execution
  - Integration with PostConfirmation trigger for automatic DB user creation
- ‚úÖ **Deployed to development environment**
  - User created: `nissim@buchs.be`
  - Cognito User ID: `2324b842-2021-707d-09f7-0bf3fc7e981c`
  - Status: CONFIRMED
  - Email verified: true
  - Custom role: organizer
  - Password: Permanent (no password reset required)

### Files Changed

**Created:**
- `infrastructure/lib/lambda/triggers/pre-token-generation.ts` - PreTokenGeneration Lambda handler with JWT role enrichment
- `infrastructure/lib/lambda/triggers/__tests__/pre-token-generation.test.ts` - 28 comprehensive unit tests for PreTokenGeneration
- `infrastructure/lib/constructs/bootstrap-organizer.ts` - BootstrapOrganizer CDK construct for environment bootstrapping
- `infrastructure/test/unit/bootstrap-organizer.test.ts` - 8 comprehensive unit tests for BootstrapOrganizer construct

**Modified:**
- `infrastructure/lib/lambda/triggers/common/database.ts` - Updated return type from Client to PoolClient for proper release() support
- `infrastructure/lib/lambda/triggers/__tests__/integration/cognito-triggers.integration.test.ts` - Added integration tests for PreTokenGeneration (pre-existing file, tests already present)
- `infrastructure/lib/stacks/cognito-stack.ts` - Integrated BootstrapOrganizer construct, fixed PreSignupLambda handler to 'index.handler'
- `infrastructure/tsconfig.json` - Excluded test files from build (`**/*.test.ts`, `**/__tests__/**`, `test/**`)
- `infrastructure/package.json` - Added jest test roots for lib directory, installed dependencies (@types/aws-lambda, @types/pg, pg, testcontainers)

**Deleted:**
- None

### Deployment Notes

**Bootstrap Organizer Deployment:**

1. **CDK Context Configuration** - Add to `cdk.json` or pass via CLI:
   ```json
   {
     "bootstrap-organizer": {
       "email": "nissim@buchs.be",
       "password": "******",
       "role": "ORGANIZER"
     }
   }
   ```

2. **Deploy Auth Stack First:**
   ```bash
   # Deploy to dev environment
   cdk deploy BATbernAuthStack-dev --context bootstrap-organizer='{"email":"nissim@buchs.be","password":"******","role":"ORGANIZER"}'

   # Verify bootstrap user created in Cognito
   aws cognito-idp admin-get-user \
     --user-pool-id <USER_POOL_ID> \
     --username nissim@buchs.be
   ```

3. **Test Bootstrap Login:**
   - Navigate to login page
   - Email: `nissim@buchs.be`
   - Password: `******`
   - Should log in immediately without password reset

**Migration Order:**
1. Apply database migration `V1_005__Create_User_Sync_Compensation_Log.sql`
2. Deploy CDK stack with Lambda triggers and bootstrap organizer
3. Deploy updated Spring Boot services with JIT interceptor
4. Verify PostConfirmation trigger created bootstrap user in database
5. Test reconciliation job manually (if needed): `POST /actuator/scheduledTasks/reconcileUsers`

**Feature Flags:**
- None required - sync patterns activate automatically on deployment

**Rollback Procedures:**
1. **Rollback CDK Stack:**
   ```bash
   cdk deploy BATbernAuthStack-dev --previous-version
   ```
   - This removes Lambda triggers but keeps Cognito users
   - Database records remain intact

2. **Rollback Database Migration:**
   ```bash
   flyway undo -target=V1_004
   ```
   - Drops `user_sync_compensation_log` table

3. **Manual Cleanup (if needed):**
   - Delete bootstrap user from Cognito if re-deploying
   - Clear compensation logs: `DELETE FROM user_sync_compensation_log WHERE retry_count >= 5;`

**Monitoring Setup:**
- CloudWatch Dashboard: `BATbern-UserSync-Dashboard`
- SNS Topic: Subscribe emails to `BATbern-UserSync-Alarms-Topic`
- Key Metrics to Watch:
  - `BATbern/UserSync/SyncLatency` - Should be <1000ms p95
  - `BATbern/UserSync/SyncFailures` - Should be 0
  - `BATbern/UserSync/DriftDetected` - Should be 0 after initial reconciliation

## QA Results

_To be filled by QA agent after implementation review_
